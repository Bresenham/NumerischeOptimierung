\documentclass[a4paper, 12pt]{report}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage{geometry}
\usepackage{csquotes}
\usepackage[toc,page]{appendix}
\usepackage{titlesec}
\usepackage{listings}
\usepackage{float}
\usepackage[hang,flushmargin]{footmisc} 
\usepackage{makecell}
\usepackage{amsmath}% http://ctan.org/pkg/amsmath
\usepackage[utf8]{inputenc}
\usepackage[default]{cantarell} %% Use option "defaultsans" to use cantarell as sans serif only
\usepackage[T1]{fontenc}
\usepackage{hyperref}
\usepackage{helvet}
\usepackage[eulergreek]{sansmath}
\usepackage{amsfonts}
\usepackage{movie15}
\usepackage{url}
\usepackage{lscape}

\usepackage{tikz}
\usetikzlibrary{calc,positioning,shapes,decorations.pathreplacing}
\usetikzlibrary{fit,fadings,shadows,patterns,math}
\usetikzlibrary{shapes.arrows,shapes.geometric}
\usetikzlibrary{arrows,arrows.meta,decorations.markings}
\usetikzlibrary{decorations.pathmorphing}

\usepackage{pgfplots}

\graphicspath{ {./images/} }
\geometry{margin=1.25in}

\newcommand*{\shifttext}[2]{%
  \settowidth{\@tempdima}{#2}%
  \makebox[\@tempdima]{\hspace*{#1}#2}%
}
\newcommand{\fakesection}[1]{%
  \par\refstepcounter{section}% Increase section counter
  \sectionmark{#1}% Add section mark (header)
  \addcontentsline{toc}{section}{\protect\numberline{\thesection}#1}% Add section to ToC
  % Add more content here, if needed.
}
\titleformat{\chapter}[display]
  {\normalfont\bfseries}{}{0pt}{\Large}
\titleformat*{\section}{\large\bfseries}

\renewcommand{\footnoterule}{%
  \kern -3pt
  \hrule width \textwidth height 1pt
  \kern 2pt
}

\newcommand\blfootnote[1]{%
  \begingroup
  \renewcommand\thefootnote{}\footnote{#1}%
  \addtocounter{footnote}{-1}%
  \endgroup
}

\begin{document}

\begin{center}
    \vspace*{2em}
    \normalsize 2. Projekt\\
    \vspace*{1em}
    \normalsize \textbf{\textit{Quasi-Newton-Verfahren \& Gauß-Newton-Verfahren}}\\
    \vspace*{4em}
    \normalsize im Fach\\
    \vspace*{1em}
    \large Numerische Optimierung\\
    \vspace*{30em}
    \normalsize Juni 2020\\
    \vspace*{1em}
    \normalsize Maximilian Gaul
\end{center}

\thispagestyle{empty}

\newpage

\subsubsection{Aufgabe 1}
Siehe Programmcode in \lstinline[basicstyle=\ttfamily\color{black}]|Project2.m|.

\newpage

\newgeometry{margin=0.25in}
\begin{landscape}
\subsubsection{Aufgabe 2}
$$\scriptscriptstyle I - \frac{s(As)^T}{s^TAs} + \frac{A^{-1}yy^T}{y^Ts} + \frac{(s - A^{-1}y)s^TA + s(s - A^{-1}y)^TA}{y^Ts} - \frac{(s - A^{-1}y)s^TAs(As)^T + s(s - A^{-1}y)^TAs(As)^T}{y^Tss^TAs} + \frac{(s - A^{-1}y)s^Tyy^T + s(s - A^{-1}y)^Tyy^T}{(y^Ts)^2} - \frac{(s - A^{-1}y)^Tyss^TA}{(y^Ts)^2} + \frac{(s - A^{-1}y)^Tyss^TAs(As)^T}{(y^Ts)^2s^TAs} - \frac{(s - A^{-1}y)^Tyss^Tyy^T}{(y^Ts)^2y^Ts}$$
$$\scriptscriptstyle I - \frac{ss^TA}{s^TAs} + \frac{A^{-1}yy^T}{y^Ts} + \frac{ss^TA - A^{-1}ys^TA + s(s^T - (A^{-1}y)^T)A}{y^Ts} - \frac{ss^TAss^TA - A^{-1}ys^TAss^TA + s(s^T - (A^{-1}y)^T)Ass^TA}{y^Tss^TAs} + \frac{ss^Tyy^T - A^{-1}ys^Tyy^T + s(s^T - (A^{-1}y)^T)yy^T}{(y^Ts)^2} -\frac{(s^T - (A^{-1}y)^T)yss^TA}{(y^Ts)^2} + \frac{(s^T - (A^{-1}y)^T)yss^TAss^TA}{(y^Ts)^2s^TAs} - \frac{(s^T - (A^{-1}y)^T)yss^Tyy^T}{(y^Ts)^2y^Ts} $$
$$\scriptscriptstyle I - \frac{ss^TA}{s^TAs} + \frac{A^{-1}yy^T}{y^Ts} + \frac{2ss^TA - A^{-1}ys^TA - sy^T}{y^Ts} - \frac{2ss^TA - A^{-1}ys^TA - sy^T}{y^Tss^TAs}\cdot ss^TA + \frac{2ss^T - A^{-1}ys^T - sy^T(A^{-1})^T}{(y^Ts)^2}\cdot yy^T -\frac{s^Ty - y^T(A^{-1})^T}{(y^Ts)^2}\cdot ss^TA + \frac{(s^T - y^T(A^{-1})^T)yss^TAss^TA}{(y^Ts)^2s^TAs} - \frac{(s^T - y^T(A^{-1})^T)yss^Tyy^T}{(y^Ts)^2y^Ts} $$
\end{landscape}
\restoregeometry

\newpage

\subsubsection{Aufgabe 3}
Wenn die Suchrichtung des BFGS Verfahrens:

$$d = -B\cdot \nabla f(x) $$

keine Abstiegsrichtung ist, d.h. die Bedingung:

$$\nabla f(x)^T \cdot d < 0 $$

nicht erfüllt ist, muss das Verfahren 'resettet' werden. In diesem Fall bietet es sich an, die Suchrichtung auf den
negativen Gradienten zu setzen:

$$d = -\nabla f(x)$$

Da nun die Abstiegsrichtung nicht mehr zur approximierten Inversen der Hesse-Matrix $B$ passt, muss diese ebenfalls für
den nächsten Schritt neu bestimmt werden (bzw. das nächste Update erfolgt dann mit dieser Matrix).\par
Hierzu bieten sich verschiedene Möglichkeiten an:

\begin{itemize}
  \item Wie beim Start des BFGS-Verfahrens $B = I$ setzen
  \begin{itemize}
    \item Hierbei geht jeglicher berechnete Fortschritt verloren, es handelt sich um einen recht naiven Ansatz
  \end{itemize}
  \item Die Hesse-Matrix einmalig aus Differenzenquotienten des Gradienten bestimmen und anschließend invertieren
  \begin{itemize}
    \item Hoher Rechenaufwand von $\mathcal{O}(n^2)$ für die Hesse-Matrix und nochmal $\mathcal{O}(n^3)$ für das Invertieren
    \item Problem wenn die Hesse-Matrix nicht invertierbar ist bzw. aufgrund von Auslöschung oder anderen numerischen Fehlern
    die Inverse schlecht konditioniert ist
    \item Bisher berechneter Fortschritt geht ebenfalls verloren aber die Approximation der Hesse-Matrix ist sehr genau
  \end{itemize}
  \item Man könnte, wie in den Vorlesungsfolien beschrieben,  $\frac{y^Ts}{y^Ty}\cdot I_n$ als positiv-definitve Matrix verwenden
\end{itemize}

Um herauszufinden, welche dieser Methoden am besten geeignet ist (d.h. die richtig Lösung in der kürzesten Zeit findet),
wird die Laufzeit des inversen BFGS-Verfahrens bestimmt. Startwerte:

\begin{itemize}
  \item N-dim. Rosenbrock-Funktion: $\begin{bmatrix}-1\\\vdots\\-1\end{bmatrix}$
  \item Himmelblau-Funktion: $\begin{bmatrix}0\\-1\end{bmatrix}$
  \item Bazaraa-Shetty: $\begin{bmatrix}0\\-1\end{bmatrix}$
\end{itemize}

\begin{figure}[H]
  \centering
  \pgfplotstableread{
    0 0.2240  0.0030  0.0051
  }\dataseth
  \pgfplotstableread{
    0 0.1904  0.0023  0.0043
  }\datasetf
  \pgfplotstableread{
    0 0.0       16.337017     3.398372
  }\datasetg
  \begin{minipage}{.3\textwidth}
    \begin{tikzpicture}
        \pgfplotsset{
          tick label style = {font=\sansmath\sffamily},
          every axis label = {font=\sansmath\sffamily},
          legend style = {font=\sansmath\sffamily},
          label style = {font=\sansmath\sffamily}
        }
        \begin{axis}[
            width=4cm,
            height=6.5cm,
            ybar,
            ymin=0,
            ymax=0.25,
            ylabel={Rechenzeit in s},
            ylabel style={xshift=-3ex},
            ytick distance=0.1,
            % ytick=\empty,
            % extra y ticks={0,0.05,0.10,0.15,0.2,0.25},
            % extra y tick labels={{0},{0.05},{0.10},{0.15},{0.2},{0.25}},
            xtick=data,
            xticklabels={
                $B = I$
            },
            yticklabel style={xshift=0ex},
            xticklabel style={yshift=-16ex},
            major x tick style={
                % (this is a better way than assigning `opacity=0')
                /pgfplots/major tick length=0pt,
            },
            minor x tick num=1,
            minor tick length=2ex,
            % ---------------------------------------------------------------------
            % (adapted solution from <https://tex.stackexchange.com/a/141006/95441>)
            % we want to provide absolute `at' values ...
            scatter/position=absolute,
            node near coords style={
                % ... to provide axis coordinates at `ymin' for the nodes
                at={(axis cs:\pgfkeysvalueof{/data point/x},\pgfkeysvalueof{/pgfplots/ymin})},
                % then also the `anchor' has to be adapted ...
                anchor=east,
                % ... because we rotate the labels which would overlap otherwise
                rotate=90,
            },
            % ---------------------------------------------------------------------
            % (created a cycle list to shorten the below `\addplot' entries)
            cycle list={
                {draw=black,fill=black!20},
                {draw=black,fill=black!40},
                {draw=black,fill=black!60},
            },
            % (moved common option here)
            table/x index=0,
        ]
            \addplot+ [nodes near coords=200-dim. Rosen.] table [y index=1] \dataseth;
            \addplot+ [nodes near coords=Himmelblau] table [y index=2] \dataseth;
            \addplot+ [nodes near coords=Bazaraa-Shetty] table [y index=3] \dataseth;
        \end{axis}
        \node[black, rotate=90, align=left] (impl) at (1.2125,1.08) {0.0030};
        \draw[-{Latex}, thick, black] (impl.west) -- ([yshift=-0.2cm]impl.west);

        \node[black, rotate=90, align=left] (impl2) at (1.6255,1.124) {0.0051};
        \draw[-{Latex}, thick, black] (impl2.west) -- ([yshift=-0.2cm]impl2.west);
    \end{tikzpicture}
  \end{minipage}
  \begin{minipage}{.3\textwidth}
    \begin{tikzpicture}
      \pgfplotsset{
        tick label style = {font=\sansmath\sffamily},
        every axis label = {font=\sansmath\sffamily},
        legend style = {font=\sansmath\sffamily},
        label style = {font=\sansmath\sffamily}
      }
        \begin{axis}[
            width=4cm,
            height=6.5cm,
            ybar,
            ymin=0,
            ymax=0.25,
            % ytick=\empty,
            % extra y ticks={0,0.05,0.10,0.15,0.2,0.25},
            % extra y tick labels={{0},{0.05},{0.10},{0.15},{0.2},{0.25}},
            xtick=data,
            xticklabels={
                $B = \frac{y^Ts}{y^Ty}\cdot I$
            },
            xticklabel style={yshift=-16ex},
            major x tick style={
                % (this is a better way than assigning `opacity=0')
                /pgfplots/major tick length=0pt,
            },
            minor x tick num=1,
            minor tick length=2ex,
            % ---------------------------------------------------------------------
            % (adapted solution from <https://tex.stackexchange.com/a/141006/95441>)
            % we want to provide absolute `at' values ...
            scatter/position=absolute,
            node near coords style={
                % ... to provide axis coordinates at `ymin' for the nodes
                at={(axis cs:\pgfkeysvalueof{/data point/x},\pgfkeysvalueof{/pgfplots/ymin})},
                % then also the `anchor' has to be adapted ...
                anchor=east,
                % ... because we rotate the labels which would overlap otherwise
                rotate=90,
            },
            % ---------------------------------------------------------------------
            % (created a cycle list to shorten the below `\addplot' entries)
            cycle list={
              {draw=black,fill=black!20},
              {draw=black,fill=black!40},
              {draw=black,fill=black!60},
            },
            % (moved common option here)
            table/x index=0,
        ]
        \addplot+ [nodes near coords=200-dim. Rosen.] table [y index=1] \datasetf;
        \addplot+ [nodes near coords=Himmelblau] table [y index=2] \datasetf;
        \addplot+ [nodes near coords=Bazaraa-Shetty] table [y index=3] \datasetf;
        \end{axis}
        \node[black, rotate=90, align=left] (impl) at (1.2125,1.055) {0.0023};
        \draw[-{Latex}, thick, black] (impl.west) -- ([yshift=-0.2cm]impl.west);

        \node[black, rotate=90, align=left] (impl2) at (1.6255,1.1) {0.0043};
        \draw[-{Latex}, thick, black] (impl2.west) -- ([yshift=-0.2cm]impl2.west);
    \end{tikzpicture}
  \end{minipage}
  \begin{minipage}{.3\textwidth}
    \begin{tikzpicture}
        \begin{axis}[
            width=4cm,
            height=6.5cm,
            ybar,
            ymin=0,
            ytick=\empty,
            extra y ticks={0,5,10,15,20,25},
            extra y tick labels={{0},{5},{10},{15},{20},{25}},
            xtick=data,
            xticklabels={
                Diff. Quot.
            },
            xticklabel style={yshift=-16ex},
            major x tick style={
                % (this is a better way than assigning `opacity=0')
                /pgfplots/major tick length=0pt,
            },
            minor x tick num=1,
            minor tick length=2ex,
            % ---------------------------------------------------------------------
            % (adapted solution from <https://tex.stackexchange.com/a/141006/95441>)
            % we want to provide absolute `at' values ...
            scatter/position=absolute,
            node near coords style={
                % ... to provide axis coordinates at `ymin' for the nodes
                at={(axis cs:\pgfkeysvalueof{/data point/x},\pgfkeysvalueof{/pgfplots/ymin})},
                % then also the `anchor' has to be adapted ...
                anchor=east,
                % ... because we rotate the labels which would overlap otherwise
                rotate=90,
            },
            % ---------------------------------------------------------------------
            % (created a cycle list to shorten the below `\addplot' entries)
            cycle list={
                {draw=black,fill=black!40},
                {draw=black,fill=black!60},
            },
            % (moved common option here)
            table/x index=0,
        ]
        \addplot+ [nodes near coords=200-dim. Rosen.] table [y index=1] \datasetg;
        \addplot+ [nodes near coords=Himmelblau] table [y index=2] \datasetg;
        \addplot+ [nodes near coords=Bazaraa-Shetty] table [y index=3] \datasetg;
        \end{axis}
    \end{tikzpicture}
  \end{minipage}
  \caption{Vergleich der Rechenzeit für eine Genauigkeit von $10^{-8}$ gemittelt über 100 Durchläufe (Intel Core i3-7100U, 8GB RAM, Windows 10 64-Bit)}
\end{figure}

Alle drei Funktionen profitieren von $B = \frac{y^Ts}{y^Ty}\cdot I$, daher habe ich diesen Weg in meiner Implementierung gewählt.

\subsubsection{Aufgabe 4}

Die Ableitung der N-dimensionalen Rosenbrock-Funktion habe ich beispielhaft für $N=3$ bestimmt:

  $$\sum_{i=1}^2 (1 - x_i)^2 + 100\cdot(x_{i+1} - x_i^2)^2$$
  $$=$$
  $$(1 - x_1)^2 + 100\cdot (x_2 - x_1^2)^2 + (1 - x_2)^2 + 100\cdot(x_3 - x_2^2)^2$$
  $$\nabla f_3 = \begin{bmatrix}-2\cdot(1 - x_1) + 200\cdot(x_2 - x_1^2)\cdot(-2x_1)\\
    200\cdot(x_2 - x_1^2) - 2\cdot(1 - x_2) + 200\cdot(x_3 - x_2^2)\cdot(-2x_2)\\
    200\cdot(x_3 - x_2^2)\end{bmatrix}$$

Man erkennt eine Regel: Der Gradient besteht aus drei Teilen. Der erste Eintrag im Gradienten ist:

$$-2\cdot(1 - x_1) + 200\cdot(x_2 - x_1^2)\cdot(-2x_1)$$

Alle weiteren Einträge (bis auf den letzten an Position $N-1$) sind:

$$200\cdot(x_i - x_{i-1}^2) - 2\cdot(1 - x_i) + 200\cdot(x_{i+1} - x_i^2)\cdot(-2x_i)$$

Der letzte Eintrag ist:

$$200\cdot(x_N - x_{N-1}^2)$$

Die Ableitung ist in \lstinline[basicstyle=\ttfamily\color{black}]|Projekt2.m| in der Funktion
\lstinline[basicstyle=\ttfamily\color{black}]|f_rosen_mult_deriv_func| definiert.
Rechenzeit des in \lstinline[basicstyle=\ttfamily\color{black}]|InverseBFGS.m| implementierten Verfahrens:

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \pgfplotsset{
      tick label style = {font=\sansmath\sffamily},
      every axis label = {font=\sansmath\sffamily},
      legend style = {font=\sansmath\sffamily},
      label style = {font=\sansmath\sffamily}
    }
    \pgfplotstableread[col sep=comma]{bfgs_ndim_rosen_measurement.csv}\datatable
    \begin{axis}[
        ybar,
        bar width=0.375pt,
        ymin=0,
        ymax=3.2,
        ytick distance=0.5,
        ylabel={Rechenzeit in s},
        xmin=0,
        xmax=450,
        xtick distance=50,
        xlabel={Dimension},
        height=4.5cm,
        width=0.95\textwidth,
        tick align=inside
      ]
      \addplot[fill=black!40, draw=black] table[x index = {0}, y index = {1}] {\datatable};
    \end{axis}
  \end{tikzpicture}
\caption{Rechenzeit der N-dimensionalen Rosenbrock-Funktion mit Startwert $[-1, \ldots, -1]^T$ für
  eine Genauigkeit von $10^{-8}$ gemittelt über 100 Durchläufe (Intel Core i3-7100U, 8GB RAM, Windows 10 64-Bit)}
\end{figure}

Rechenzeit von \lstinline[basicstyle=\ttfamily\color{black}]|fminunc| mit Option
\lstinline[basicstyle=\ttfamily\color{black}]|"HessUpdate" = "bfgs"|:

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \pgfplotsset{
      tick label style = {font=\sansmath\sffamily},
      every axis label = {font=\sansmath\sffamily},
      legend style = {font=\sansmath\sffamily},
      label style = {font=\sansmath\sffamily}
    }
    \pgfplotstableread[col sep=comma]{fminunc_ndim_rosen_measurement.csv}\datatable
    \begin{axis}[
        ybar,
        bar width=0.375pt,
        ymin=0,
        ymax=3.2,
        ytick distance=0.5,
        ylabel={Rechenzeit in s},
        xmin=0,
        xmax=450,
        xtick distance=50,
        xlabel={Dimension},
        height=4.5cm,
        width=0.95\textwidth,
        tick align=inside
      ]
      \addplot[fill=black!40, draw=black] table[x index = {0}, y index = {1}] {\datatable};
    \end{axis}
  \end{tikzpicture}
\caption{Rechenzeit der N-dimensionalen Rosenbrock-Funktion mit Startwert $[-1, \ldots, -1]^T$ für
  eine Genauigkeit von $10^{-8}$ gemittelt über 100 Durchläufe (Intel Core i3-7100U, 8GB RAM, Windows 10 64-Bit)}
\end{figure}

Man erkennt, das mit höheren Dimensionen die Rechenzeit für beide Verfahren drastisch zunimmt.\par

Möglichkeiten um ein höheres $N$ zu erreichen:
\begin{itemize}
  \item Nach den Regeln der Analysis lässt sich eine Summe aufteilen in zwei Summen:
  $$\sum_{i=1}^{N-1}(1 - x_i)^2 + 100\cdot(x_{i+1}-x_i^2)^2$$
  $$=$$
  $$\sum_{i=1}^{a}(1 - x_i)^2 + 100\cdot(x_{i+1}-x_i^2)^2 + \sum_{i=a+1}^{N-1}(1 - x_i)^2 + 100\cdot(x_{i+1}-x_i^2)^2$$
  Die Berechnung des Minimums dieser zwei Summen kann auf z.B. zwei Threads aufgeteilt und am Ende wieder zusammengefügt werden.
  Bei ungeradem $N$ muss man sich entscheiden wie die Summe aufgeteilt wird, ein Thread bearbeitet dann eine Dimension mehr als der andere.
  Bei besonders großem $N$ können auch diese beiden Summen wiederum aufgeteilt und somit auf noch mehr Threads verteilt werden.
  \item Verwenden von sparse-Matritzen und Vektoren durch die sich die Rechenzeit unter Umständen reduzieren kann. Sparse-Datenstrukturen
  verwenden eine spezielle Repräsentation der Werte in denen Einträge mit $0$ effizienter gespeichert werden. Aufgrundessen beschleunigt
  sich die Berechnung von Matrix-Vektor-Produkten (die beim BFGS-Verfahren sehr oft verwendet werden)
  \item Gegebenfalls genauere Untersuchungen über Kondition und Stabilität der Operationen bzw. wie diese verbessert werden können.
  Durch Auslöschung in der Update-Formel könnte es unter Umständen zu fehlerhaften Richtungsvektoren kommen die sich bei besonders
  großen Problemen potenzieren und somit die Konvergenz verlangsamen.
\end{itemize}

\subsubsection{Aufgabe 5}


\subsubsection{Aufgabe 6}

Siehe \lstinline[basicstyle=\ttfamily\color{black}]|GaussNewton.m|.

\subsubsection{Aufgabe 7}

Siehe \lstinline[basicstyle=\ttfamily\color{black}]|Projekt2.m|.

\subsubsection{Aufgabe 8}

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \newcommand*{\from}{-0.5}
    \newcommand*{\too}{3.5}
    \newcommand*{\scaleFactor}{1.5}
    \tikzstyle{interval border}=[thin, red];

    \draw[-{Latex}] (\from,0) -- (\too*\scaleFactor,0) node[right] {$t$};
    \draw[-{Latex}] (0,\from) -- (0,\too*\scaleFactor) node[above] {\rotatebox{0}{$f(t, 1.995, -1.0095)$}}; 
    \draw[scale=\scaleFactor, thick, black, domain=\from:\too, smooth, variable=\x] plot ({\x},{1.995 * exp(-1.0095 * \x)});

    \draw (0, 0) node[xshift=-0.21cm, yshift=-0.25cm, font=\small] {$0$};

    \foreach \x in {1, 2, 3} {
      \draw (\x*\scaleFactor, 0) node[yshift=-0.25cm, font=\small] {$\x$};
      \draw (0,\x*\scaleFactor) node[xshift=-0.25cm, font=\small] {$\x$};
    }

    \foreach \x / \y / \i in {0/2.0/1, 1/0.7/2, 2/0.3/3, 3/0.1/4} {
      \draw (\x*\scaleFactor, \y*\scaleFactor) node[interval border] {x};
    }
  \end{tikzpicture}
  \caption{Modellfunktion und Datensatz für $f(t, x_1, x_2) = x_1\cdot e^{x_2\cdot t}$}
\end{figure}

\end{document}